from pathlib import PurePosixPath

from .schema import Schematic, Configurable, fields
from .operation import Operation, Response, Parameter, RequestBody, Header, Link
from . import common
from .data import DataKey
from .util import get_schema, build_parameters
from flask import Blueprint


def setup_operations(cls):
    for name, attr in vars(cls).items():
        if isinstance(attr, LazyOperation):
            LazyOperation


def operation(**kwargs):
    def decorator(fn):
        return LazyOperation(callable=fn, kwargs=kwargs)
    return decorator

class Contact(Schematic):
    name = fields.String(required=True, description="The identifying name of the contact person/organization.")
    url = fields.String(description="The URL pointing to the contact information. MUST be in the format of a URL.")
    email = fields.String(email="The email address of the contact person/organization. MUST be in the format of an email address.")

class License(Schematic):
    name = fields.String(required=True, description="The license name used for the API.")
    url = fields.String(description="A URL to the license used for the API. MUST be in the format of a URL.")

class Server(Schematic):
    url = fields.String(required=True)
    description = fields.String(required=True)

class ExternalDoc(Schematic):
    description = fields.String(description='A short description of the target documentation. CommonMark syntax MAY be used for rich text representation.')
    url = fields.URIString(required=True, description='The URL for the target documentation. Value MUST be in the format of a URL.')

class Info(Schematic):
    title = fields.String(required=True, description="The title of the application.")
    description = fields.String(description="A short description of the application. CommonMark syntax MAY be used for rich text representation.")
    terms_of_service = fields.URIString(description="A URL to the Terms of Service for the API. MUST be in the format of a URL.")
    contact = fields.InstanceOf(Contact)
    license = fields.InstanceOf(License)
    version = fields.String(required=True, description="The version of the OpenAPI document (which is distinct from the OpenAPI Specification version or the API implementation version).")

class OAuthFlow(Schematic):
    authorization_url = fields.URIString(required=True, description="The authorization URL to be used for this flow. This MUST be in the form of a URL.")
    token_url = fields.URIString(required=True, description="The token URL to be used for this flow. This MUST be in the form of a URL.")
    refresh_url = fields.URIString(description='The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL.')
    scopes = fields.String(required=True, map=True, description='The available scopes for the OAuth2 security scheme. A map between the scope name and a short description for it.')

class OAuthFlowSet(Schematic):
    implicit = fields.InstanceOf(OAuthFlow, description="Configuration for the OAuth Implicit flow")
    password = fields.InstanceOf(OAuthFlow, description="Configuration for the OAuth Resource Owner Password flow")
    client_credentials = fields.InstanceOf(OAuthFlow, description="Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0.")
    authorization_code = fields.InstanceOf(OAuthFlow, description="Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.")

class SecurityScheme(Schematic):
    type = fields.Enum(["apiKey", "http", "oauth2", "openIdConnect"], required=True, description='The type of the security scheme.')
    description = fields.String(description="A short description for security scheme. CommonMark syntax MAY be used for rich text representation.")
    name = fields.String(description='The name of the header, query or cookie parameter to be used.')
    location = fields.Enum(["query", "header", "cookie"], description='The location of the API key.', alias='in')
    scheme = fields.String(description="The name of the HTTP Authorization scheme to be used in the Authorization header as defined in RFC7235.")
    bearerFormat = fields.String(description="A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually generated by an authorization server, so this information is primarily for documentation purposes.")
    flows = fields.InstanceOf(OAuthFlowSet, description="An object containing configuration information for the flow types supported.")
    open_id_connect_url = fields.URIString(description='OpenId Connect URL to discover OAuth2 configuration values. This MUST be in the form of a URL.')

class Example(Schematic):
    summary = fields.String(required=True, description='Short description for the example.')
    description = fields.String(description='Long description for the example. CommonMark syntax MAY be used for rich text representation.')
    value = fields.Any(description='Embedded literal example. The value field and externalValue field are mutually exclusive. To represent examples of media types that cannot naturally represented in JSON or YAML, use a string value to contain the example, escaping where necessary.')
    external_value = fields.URIString(description='A URL that points to the literal example. This provides the capability to reference examples that cannot easily be included in JSON or YAML documents. The value field and externalValue field are mutually exclusive.')

class PathItem(Schematic):
    summary = fields.String()
    description = fields.String()
    get = fields.InstanceOf(Operation)
    put = fields.InstanceOf(Operation)
    delete = fields.InstanceOf(Operation)
    options = fields.InstanceOf(Operation)
    head = fields.InstanceOf(Operation)
    patch = fields.InstanceOf(Operation)
    trace = fields.InstanceOf(Operation)
    servers = fields.InstanceOf(Server, repeated=True)
    parameters = fields.InstanceOf(Parameter, repeated=True)

    def register(self, app, options, first_registration=False):
        for method, v in vars(self).items():
            if isinstance(v, Operation):
                options = dict(options, methods=[method])
                v.register(app, options, first_registration=first_registration)

class Components(Schematic):
    schema = fields.SchemaField(map=True)
    responses = fields.InstanceOf(Response, map=True)
    parameters = fields.InstanceOf(Parameter, map=True)
    examples = fields.InstanceOf(Example, map=True)
    request_bodies = fields.InstanceOf(Parameter, map=True)
    headers = fields.InstanceOf(Header, map=True)
    security_schemes = fields.InstanceOf(SecurityScheme, map=True)
    links = fields.InstanceOf(Link, map=True)
    callbacks = fields.InstanceOf(PathItem, map=True)
    parameters = fields.InstanceOf(Parameter, map=True)

class Tag(Schematic):
    name = fields.String(required=True, description='The name of the tag.')
    description = fields.String(description='A short description for the tag. CommonMark syntax MAY be used for rich text representation.')
    external_docs = fields.InstanceOf(ExternalDoc)

class Collection(Schematic):
    """
    A collection is a Splendor specific construct that describes a group of operations that have a common schema.
    """
    title = fields.String(required=True)
    schema = fields.SchemaField()
    auditor = fields.Callable(default=None)
    storage = fields.Duck(["save", "load", "delete"])
    filters = fields.InstanceOf(fields.Field, map=True)
    paths = fields.Dict(map=True, default={
        '/':        {'get': 'list_items',
                     'post': 'post_item'},
        '/<id>':    {'get': 'get_item',
                     'put': 'put_item',
                     'patch': 'patch_item',
                     'delete': 'delete_item'}
    })
    url_prefix = fields.InstanceOf(PurePosixPath, export=False)

    ### Meta ###
    def __repr__(self):
        return f'{self.__class__}({self.title})'

    def register_operation(self, app, options, fn, first_registration=False):
        path = PurePosixPath(options.get('url_prefix', ''))
        if isinstance(fn, str):
            fn = getattr(self, fn)
        if isinstance(fn, common.OperationTemplate):
            fn = fn.build(self, self.schema, name=self.name)
        if isinstance(fn, Operation):
            fn.operation_id = f'{self.name}:{fn.__name__}'
            fn.register(app, options, first_registration=first_registration)
        else:
            fn = Operation(callable=fn, 
                           operation_id=f'{self.name}:{fn.__name__}',
                           method=options.get('methods', ['get'])[0].lower(),
                           parameters=build_parameters(fn, path=str(path)),
                           description=fn.__doc__)
            fn.register(app, options, first_registration=first_registration)
        return fn

    def register(self, app, options, first_registration=False):
        self.url_prefix = PurePosixPath(options.get('url_prefix', ''))

        for path, mapping_or_fn in self.paths.items():
            path = self.url_prefix / path.lstrip('/')
            options = dict(options, url_prefix=path)

            if isinstance(mapping_or_fn, dict):
                for method, view_func in mapping_or_fn.items():
                    options = dict(options, methods=[method])
                    self.register_operation(app, options, view_func, first_registration=first_registration)
            else:
                self.register_operation(app, options, mapping_or_fn, first_registration=first_registration)


    @property
    def name(self):
        return self.title.lower()

    ### Interface ###
    def save(self, key, item, partial=False):
        return self.storage.save(self.schema, key, item, partial)

    def load(self, key):
        return self.storage.load(self.schema, key)

    def delete(self, key):
        return self.storage.delete(self.schema, key)

    def query(self, **filters):
        return self.storage.query(self.schema, filters)

    def audit(self, perm, **args):
        if self.auditor:
            self.auditor(self, perm, **args)

    def enrich(self, key, item):
        if key.id is not None:
            item['_url'] = f'{self.url_prefix}/{key.id}'
        if '_key' in item:
            item['_key'] = str(key)
        return item

    def enrich_results(self, results):
        results = [self.enrich(item['_key'], item) for item in results]
        return results


    ### Operations ###
    @common.listing
    def list_items(self, q=""):
        self.audit('list', query=q)
        return self.enrich_results(self.query(q=q))
    
    @common.post
    def post_item(self, item):
        self.audit('post', item=item)
        key, item = self.save(None, item)
        return self.enrich(key, item)
    
    @common.get
    def get_item(self, id):
        key = DataKey(self.schema.name, id)
        self.audit('get:key', key=key)
        item = self.load(key)
        if item is None:
            return 404
        self.audit('get:item', key=key, item=item)
        return self.enrich(key, item)
    
    @common.put
    def put_item(self, id, item):
        key = DataKey(self.schema.name, id)
        self.audit('put', key=key, item=item)
        key, item = self.save(key, item)
        return self.enrich(key, item)
    
    @common.patch
    def patch_item(self, id, item):
        key = DataKey(self.schema.name, id)
        self.audit('patch', key=key, item=item)
        key, item = self.save(key, item, partial=True)
        return self.enrich(key, self.schema(item))
    
    @common.delete
    def delete_item(self, id):
        key = DataKey(self.schema.name, id)
        self.audit('delete', key=key)
        self.delete(key)


class Storage(Configurable):
    collection = fields.InstanceOf(Collection)

    def save(self, schema, key, item, partial=False):
        pass

    def load(self, schema, key):
        pass

    def delete(self, schema, key):
        pass

    def query(self, schema, filters):
        pass


class Api(Schematic):
    openapi = fields.String(required=True, default='3.0.1', description='This string MUST be the semantic version number of the OpenAPI Specification version that the OpenAPI document uses. The openapi field SHOULD be used by tooling specifications and clients to interpret the OpenAPI document. This is not related to the API info.version string.')
    info = fields.InstanceOf(Info, required=True, description='Provides metadata about the API. The metadata MAY be used by tooling as required.')
    servers = fields.InstanceOf(Server, repeated=True, description='An array of Server Objects, which provide connectivity information to a target server. If the servers property is not provided, or is an empty array, the default value would be a Server Object with a url value of /.')
    paths = fields.AnyInstanceOf([PathItem, Collection], map=True, description='The available paths and operations for the API.')
    components = fields.InstanceOf(Components, description='An element to hold various schemas for the specification.', default=Components)
    security = fields.List(map=True, items={'type': 'str'}, description='A declaration of which security mechanisms can be used across the API. The list of values includes alternative security requirement objects that can be used. Only one of the security requirement objects need to be satisfied to authorize a request. Individual operations can override this definition.')
    tags = fields.InstanceOf(Tag, repeated=True, description='A list of tags used by the specification with additional metadata. The order of the tags can be used to reflect on their order by the parsing tools. Not all tags that are used by the Operation Object must be declared. The tags that are not declared MAY be organized randomly or based on the tools\' logic. Each tag name in the list MUST be unique.')
    external_docs = fields.InstanceOf(ExternalDoc, description="A list of external doc objects to reference.")
    _url_prefix = fields.InstanceOf(PurePosixPath, export=False, description="The prefix that this API lives at in the flask App.", default="/")
    _collections = fields.InstanceOf(Collection, map=True, export=False, description="All collections registered to the api.")

    def register(self, app, options, first_registration=False):
        self._url_prefix = PurePosixPath(options.get('url_prefix', '/'))
        for path, resource in self.paths.items():
            path = self._url_prefix / path.lstrip('/')

            if isinstance(resource, type):
                resource = resource()

            options = dict(options, url_prefix=path)
            resource.register(app, options, first_registration=first_registration)

            if isinstance(resource, Collection):
                self._collections[resource.name] = resource

    @property
    def name(self):
        return f"{self.info.title}_{self.info.version}"


# TODO: 
# Register API
# Datastore
# Extra posts
# Security
# Responses
# Respond sensetive to Accept
# Export



